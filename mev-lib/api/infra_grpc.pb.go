// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.4
// source: infra.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MEVInfraClient is the client API for MEVInfra service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MEVInfraClient interface {
	// SubscribeTxpool opens a stream of transactions in the txpool, whenever there is a change.
	// Transactions with the same tx may be returned multiple times, if the state changes.
	SubscribeTxpool(ctx context.Context, opts ...grpc.CallOption) (MEVInfra_SubscribeTxpoolClient, error)
	// Simulate returns the results of simulating a bundle of transactions.
	// The results are streamed back immediately, as they are available.
	// The client could cancel the stream at any time, if they are no longer interested in the results.
	Simulate(ctx context.Context, in *SimulateRequest, opts ...grpc.CallOption) (MEVInfra_SimulateClient, error)
	// WatchState opens a stream where the client could set up watches for state changes, and listen to changes in real-time.
	WatchState(ctx context.Context, in *WatchStateRequest, opts ...grpc.CallOption) (MEVInfra_WatchStateClient, error)
	// WatchState opens a stream where the client could set up watches for state changes, and listen to changes in real-time.
	WatchStateStream(ctx context.Context, opts ...grpc.CallOption) (MEVInfra_WatchStateStreamClient, error)
	// HistoricalState returns the state at a given block number.
	HistoricalState(ctx context.Context, in *HistoricalStateRequest, opts ...grpc.CallOption) (*HistoricalStateResponse, error)
	// UpdateTxpoolWhitelist updates the whitelist of addresses that are allowed to be included in the txpool.
	UpdateTxpoolWhitelist(ctx context.Context, in *UpdateTxpoolWhitelistRequest, opts ...grpc.CallOption) (*UpdateTxpoolWhitelistResponse, error)
	// DumpTxpoolWhitelist returns the whitelist of addresses that are allowed to be included in the txpool.
	DumpTxpoolWhitelist(ctx context.Context, in *DumpTxpoolWhitelistRequest, opts ...grpc.CallOption) (*DumpTxpoolWhitelistResponse, error)
	// RelayTxFeed opens a stream so that a relay can send directly transactions into the node without going through p2p.
	RelayTxFeed(ctx context.Context, opts ...grpc.CallOption) (MEVInfra_RelayTxFeedClient, error)
	// BatchBundle submits a batch of bundles to txpool.
	// This helps reduce unnecessary contentions/context switches by directly telling the system
	// to process a whole batch of bundles.
	// The batch could be transparently passed to relay nodes, so that they could also broadcast the bundles in a batch.
	BatchBundle(ctx context.Context, in *BatchBundleRequest, opts ...grpc.CallOption) (*BatchBundleResponse, error)
	BroadcastBatchBundle(ctx context.Context, in *BroadcastBatchBundleRequest, opts ...grpc.CallOption) (*BroadcastBatchBundleResponse, error)
	// WatchBatchBundleV2 opens a stream so that a relay can capture bundles (in batches) that need to be broadcast.
	WatchBatchBundleV2(ctx context.Context, in *WatchBatchBundleRequest, opts ...grpc.CallOption) (MEVInfra_WatchBatchBundleV2Client, error)
	// GetRawHeaders returns the raw headers (rlp encoded) given a list of block numbers or block hashes.
	GetRawHeaders(ctx context.Context, in *GetRawHeadersRequest, opts ...grpc.CallOption) (*GetRawHeadersResponse, error)
	EthCall(ctx context.Context, in *EthCallRequest, opts ...grpc.CallOption) (*EthCallResponse, error)
	ServeHeaders(ctx context.Context, in *ServeHeadersRequest, opts ...grpc.CallOption) (*ServeHeadersResponse, error)
	ServeBodies(ctx context.Context, in *ServeBodiesRequest, opts ...grpc.CallOption) (*ServeBodiesResponse, error)
	ServeSnap(ctx context.Context, in *ServeSnapRequest, opts ...grpc.CallOption) (*ServeSnapResponse, error)
	RegisterLocalAccounts(ctx context.Context, in *RegisterLocalAccountsRequest, opts ...grpc.CallOption) (*RegisterLocalAccountsResponse, error)
	PrepareSimulateEnv(ctx context.Context, in *PrepareSimulateEnvRequest, opts ...grpc.CallOption) (*PrepareSimulateEnvResponse, error)
}

type mEVInfraClient struct {
	cc grpc.ClientConnInterface
}

func NewMEVInfraClient(cc grpc.ClientConnInterface) MEVInfraClient {
	return &mEVInfraClient{cc}
}

func (c *mEVInfraClient) SubscribeTxpool(ctx context.Context, opts ...grpc.CallOption) (MEVInfra_SubscribeTxpoolClient, error) {
	stream, err := c.cc.NewStream(ctx, &MEVInfra_ServiceDesc.Streams[0], "/mev.MEVInfra/SubscribeTxpool", opts...)
	if err != nil {
		return nil, err
	}
	x := &mEVInfraSubscribeTxpoolClient{stream}
	return x, nil
}

type MEVInfra_SubscribeTxpoolClient interface {
	Send(*SubscribeTxpoolRequest) error
	Recv() (*SubscribeTxpoolResponse, error)
	grpc.ClientStream
}

type mEVInfraSubscribeTxpoolClient struct {
	grpc.ClientStream
}

func (x *mEVInfraSubscribeTxpoolClient) Send(m *SubscribeTxpoolRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mEVInfraSubscribeTxpoolClient) Recv() (*SubscribeTxpoolResponse, error) {
	m := new(SubscribeTxpoolResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mEVInfraClient) Simulate(ctx context.Context, in *SimulateRequest, opts ...grpc.CallOption) (MEVInfra_SimulateClient, error) {
	stream, err := c.cc.NewStream(ctx, &MEVInfra_ServiceDesc.Streams[1], "/mev.MEVInfra/Simulate", opts...)
	if err != nil {
		return nil, err
	}
	x := &mEVInfraSimulateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MEVInfra_SimulateClient interface {
	Recv() (*SimulateResponse, error)
	grpc.ClientStream
}

type mEVInfraSimulateClient struct {
	grpc.ClientStream
}

func (x *mEVInfraSimulateClient) Recv() (*SimulateResponse, error) {
	m := new(SimulateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mEVInfraClient) WatchState(ctx context.Context, in *WatchStateRequest, opts ...grpc.CallOption) (MEVInfra_WatchStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &MEVInfra_ServiceDesc.Streams[2], "/mev.MEVInfra/WatchState", opts...)
	if err != nil {
		return nil, err
	}
	x := &mEVInfraWatchStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MEVInfra_WatchStateClient interface {
	Recv() (*WatchStateResponse, error)
	grpc.ClientStream
}

type mEVInfraWatchStateClient struct {
	grpc.ClientStream
}

func (x *mEVInfraWatchStateClient) Recv() (*WatchStateResponse, error) {
	m := new(WatchStateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mEVInfraClient) WatchStateStream(ctx context.Context, opts ...grpc.CallOption) (MEVInfra_WatchStateStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &MEVInfra_ServiceDesc.Streams[3], "/mev.MEVInfra/WatchStateStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &mEVInfraWatchStateStreamClient{stream}
	return x, nil
}

type MEVInfra_WatchStateStreamClient interface {
	Send(*WatchStateStreamRequest) error
	Recv() (*WatchStateResponse, error)
	grpc.ClientStream
}

type mEVInfraWatchStateStreamClient struct {
	grpc.ClientStream
}

func (x *mEVInfraWatchStateStreamClient) Send(m *WatchStateStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mEVInfraWatchStateStreamClient) Recv() (*WatchStateResponse, error) {
	m := new(WatchStateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mEVInfraClient) HistoricalState(ctx context.Context, in *HistoricalStateRequest, opts ...grpc.CallOption) (*HistoricalStateResponse, error) {
	out := new(HistoricalStateResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/HistoricalState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) UpdateTxpoolWhitelist(ctx context.Context, in *UpdateTxpoolWhitelistRequest, opts ...grpc.CallOption) (*UpdateTxpoolWhitelistResponse, error) {
	out := new(UpdateTxpoolWhitelistResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/UpdateTxpoolWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) DumpTxpoolWhitelist(ctx context.Context, in *DumpTxpoolWhitelistRequest, opts ...grpc.CallOption) (*DumpTxpoolWhitelistResponse, error) {
	out := new(DumpTxpoolWhitelistResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/DumpTxpoolWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) RelayTxFeed(ctx context.Context, opts ...grpc.CallOption) (MEVInfra_RelayTxFeedClient, error) {
	stream, err := c.cc.NewStream(ctx, &MEVInfra_ServiceDesc.Streams[4], "/mev.MEVInfra/RelayTxFeed", opts...)
	if err != nil {
		return nil, err
	}
	x := &mEVInfraRelayTxFeedClient{stream}
	return x, nil
}

type MEVInfra_RelayTxFeedClient interface {
	Send(*RelayTxFeedRequest) error
	CloseAndRecv() (*RelayTxFeedResponse, error)
	grpc.ClientStream
}

type mEVInfraRelayTxFeedClient struct {
	grpc.ClientStream
}

func (x *mEVInfraRelayTxFeedClient) Send(m *RelayTxFeedRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mEVInfraRelayTxFeedClient) CloseAndRecv() (*RelayTxFeedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RelayTxFeedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mEVInfraClient) BatchBundle(ctx context.Context, in *BatchBundleRequest, opts ...grpc.CallOption) (*BatchBundleResponse, error) {
	out := new(BatchBundleResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/BatchBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) BroadcastBatchBundle(ctx context.Context, in *BroadcastBatchBundleRequest, opts ...grpc.CallOption) (*BroadcastBatchBundleResponse, error) {
	out := new(BroadcastBatchBundleResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/BroadcastBatchBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) WatchBatchBundleV2(ctx context.Context, in *WatchBatchBundleRequest, opts ...grpc.CallOption) (MEVInfra_WatchBatchBundleV2Client, error) {
	stream, err := c.cc.NewStream(ctx, &MEVInfra_ServiceDesc.Streams[5], "/mev.MEVInfra/WatchBatchBundleV2", opts...)
	if err != nil {
		return nil, err
	}
	x := &mEVInfraWatchBatchBundleV2Client{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MEVInfra_WatchBatchBundleV2Client interface {
	Recv() (*WatchBatchBundleV2Response, error)
	grpc.ClientStream
}

type mEVInfraWatchBatchBundleV2Client struct {
	grpc.ClientStream
}

func (x *mEVInfraWatchBatchBundleV2Client) Recv() (*WatchBatchBundleV2Response, error) {
	m := new(WatchBatchBundleV2Response)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mEVInfraClient) GetRawHeaders(ctx context.Context, in *GetRawHeadersRequest, opts ...grpc.CallOption) (*GetRawHeadersResponse, error) {
	out := new(GetRawHeadersResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/GetRawHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) EthCall(ctx context.Context, in *EthCallRequest, opts ...grpc.CallOption) (*EthCallResponse, error) {
	out := new(EthCallResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/EthCall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) ServeHeaders(ctx context.Context, in *ServeHeadersRequest, opts ...grpc.CallOption) (*ServeHeadersResponse, error) {
	out := new(ServeHeadersResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/ServeHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) ServeBodies(ctx context.Context, in *ServeBodiesRequest, opts ...grpc.CallOption) (*ServeBodiesResponse, error) {
	out := new(ServeBodiesResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/ServeBodies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) ServeSnap(ctx context.Context, in *ServeSnapRequest, opts ...grpc.CallOption) (*ServeSnapResponse, error) {
	out := new(ServeSnapResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/ServeSnap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) RegisterLocalAccounts(ctx context.Context, in *RegisterLocalAccountsRequest, opts ...grpc.CallOption) (*RegisterLocalAccountsResponse, error) {
	out := new(RegisterLocalAccountsResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/RegisterLocalAccounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mEVInfraClient) PrepareSimulateEnv(ctx context.Context, in *PrepareSimulateEnvRequest, opts ...grpc.CallOption) (*PrepareSimulateEnvResponse, error) {
	out := new(PrepareSimulateEnvResponse)
	err := c.cc.Invoke(ctx, "/mev.MEVInfra/PrepareSimulateEnv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MEVInfraServer is the server API for MEVInfra service.
// All implementations must embed UnimplementedMEVInfraServer
// for forward compatibility
type MEVInfraServer interface {
	// SubscribeTxpool opens a stream of transactions in the txpool, whenever there is a change.
	// Transactions with the same tx may be returned multiple times, if the state changes.
	SubscribeTxpool(MEVInfra_SubscribeTxpoolServer) error
	// Simulate returns the results of simulating a bundle of transactions.
	// The results are streamed back immediately, as they are available.
	// The client could cancel the stream at any time, if they are no longer interested in the results.
	Simulate(*SimulateRequest, MEVInfra_SimulateServer) error
	// WatchState opens a stream where the client could set up watches for state changes, and listen to changes in real-time.
	WatchState(*WatchStateRequest, MEVInfra_WatchStateServer) error
	// WatchState opens a stream where the client could set up watches for state changes, and listen to changes in real-time.
	WatchStateStream(MEVInfra_WatchStateStreamServer) error
	// HistoricalState returns the state at a given block number.
	HistoricalState(context.Context, *HistoricalStateRequest) (*HistoricalStateResponse, error)
	// UpdateTxpoolWhitelist updates the whitelist of addresses that are allowed to be included in the txpool.
	UpdateTxpoolWhitelist(context.Context, *UpdateTxpoolWhitelistRequest) (*UpdateTxpoolWhitelistResponse, error)
	// DumpTxpoolWhitelist returns the whitelist of addresses that are allowed to be included in the txpool.
	DumpTxpoolWhitelist(context.Context, *DumpTxpoolWhitelistRequest) (*DumpTxpoolWhitelistResponse, error)
	// RelayTxFeed opens a stream so that a relay can send directly transactions into the node without going through p2p.
	RelayTxFeed(MEVInfra_RelayTxFeedServer) error
	// BatchBundle submits a batch of bundles to txpool.
	// This helps reduce unnecessary contentions/context switches by directly telling the system
	// to process a whole batch of bundles.
	// The batch could be transparently passed to relay nodes, so that they could also broadcast the bundles in a batch.
	BatchBundle(context.Context, *BatchBundleRequest) (*BatchBundleResponse, error)
	BroadcastBatchBundle(context.Context, *BroadcastBatchBundleRequest) (*BroadcastBatchBundleResponse, error)
	// WatchBatchBundleV2 opens a stream so that a relay can capture bundles (in batches) that need to be broadcast.
	WatchBatchBundleV2(*WatchBatchBundleRequest, MEVInfra_WatchBatchBundleV2Server) error
	// GetRawHeaders returns the raw headers (rlp encoded) given a list of block numbers or block hashes.
	GetRawHeaders(context.Context, *GetRawHeadersRequest) (*GetRawHeadersResponse, error)
	EthCall(context.Context, *EthCallRequest) (*EthCallResponse, error)
	ServeHeaders(context.Context, *ServeHeadersRequest) (*ServeHeadersResponse, error)
	ServeBodies(context.Context, *ServeBodiesRequest) (*ServeBodiesResponse, error)
	ServeSnap(context.Context, *ServeSnapRequest) (*ServeSnapResponse, error)
	RegisterLocalAccounts(context.Context, *RegisterLocalAccountsRequest) (*RegisterLocalAccountsResponse, error)
	PrepareSimulateEnv(context.Context, *PrepareSimulateEnvRequest) (*PrepareSimulateEnvResponse, error)
	mustEmbedUnimplementedMEVInfraServer()
}

// UnimplementedMEVInfraServer must be embedded to have forward compatible implementations.
type UnimplementedMEVInfraServer struct {
}

func (UnimplementedMEVInfraServer) SubscribeTxpool(MEVInfra_SubscribeTxpoolServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTxpool not implemented")
}
func (UnimplementedMEVInfraServer) Simulate(*SimulateRequest, MEVInfra_SimulateServer) error {
	return status.Errorf(codes.Unimplemented, "method Simulate not implemented")
}
func (UnimplementedMEVInfraServer) WatchState(*WatchStateRequest, MEVInfra_WatchStateServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchState not implemented")
}
func (UnimplementedMEVInfraServer) WatchStateStream(MEVInfra_WatchStateStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchStateStream not implemented")
}
func (UnimplementedMEVInfraServer) HistoricalState(context.Context, *HistoricalStateRequest) (*HistoricalStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HistoricalState not implemented")
}
func (UnimplementedMEVInfraServer) UpdateTxpoolWhitelist(context.Context, *UpdateTxpoolWhitelistRequest) (*UpdateTxpoolWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTxpoolWhitelist not implemented")
}
func (UnimplementedMEVInfraServer) DumpTxpoolWhitelist(context.Context, *DumpTxpoolWhitelistRequest) (*DumpTxpoolWhitelistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpTxpoolWhitelist not implemented")
}
func (UnimplementedMEVInfraServer) RelayTxFeed(MEVInfra_RelayTxFeedServer) error {
	return status.Errorf(codes.Unimplemented, "method RelayTxFeed not implemented")
}
func (UnimplementedMEVInfraServer) BatchBundle(context.Context, *BatchBundleRequest) (*BatchBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchBundle not implemented")
}
func (UnimplementedMEVInfraServer) BroadcastBatchBundle(context.Context, *BroadcastBatchBundleRequest) (*BroadcastBatchBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastBatchBundle not implemented")
}
func (UnimplementedMEVInfraServer) WatchBatchBundleV2(*WatchBatchBundleRequest, MEVInfra_WatchBatchBundleV2Server) error {
	return status.Errorf(codes.Unimplemented, "method WatchBatchBundleV2 not implemented")
}
func (UnimplementedMEVInfraServer) GetRawHeaders(context.Context, *GetRawHeadersRequest) (*GetRawHeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRawHeaders not implemented")
}
func (UnimplementedMEVInfraServer) EthCall(context.Context, *EthCallRequest) (*EthCallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EthCall not implemented")
}
func (UnimplementedMEVInfraServer) ServeHeaders(context.Context, *ServeHeadersRequest) (*ServeHeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServeHeaders not implemented")
}
func (UnimplementedMEVInfraServer) ServeBodies(context.Context, *ServeBodiesRequest) (*ServeBodiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServeBodies not implemented")
}
func (UnimplementedMEVInfraServer) ServeSnap(context.Context, *ServeSnapRequest) (*ServeSnapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServeSnap not implemented")
}
func (UnimplementedMEVInfraServer) RegisterLocalAccounts(context.Context, *RegisterLocalAccountsRequest) (*RegisterLocalAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterLocalAccounts not implemented")
}
func (UnimplementedMEVInfraServer) PrepareSimulateEnv(context.Context, *PrepareSimulateEnvRequest) (*PrepareSimulateEnvResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareSimulateEnv not implemented")
}
func (UnimplementedMEVInfraServer) mustEmbedUnimplementedMEVInfraServer() {}

// UnsafeMEVInfraServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MEVInfraServer will
// result in compilation errors.
type UnsafeMEVInfraServer interface {
	mustEmbedUnimplementedMEVInfraServer()
}

func RegisterMEVInfraServer(s grpc.ServiceRegistrar, srv MEVInfraServer) {
	s.RegisterService(&MEVInfra_ServiceDesc, srv)
}

func _MEVInfra_SubscribeTxpool_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MEVInfraServer).SubscribeTxpool(&mEVInfraSubscribeTxpoolServer{stream})
}

type MEVInfra_SubscribeTxpoolServer interface {
	Send(*SubscribeTxpoolResponse) error
	Recv() (*SubscribeTxpoolRequest, error)
	grpc.ServerStream
}

type mEVInfraSubscribeTxpoolServer struct {
	grpc.ServerStream
}

func (x *mEVInfraSubscribeTxpoolServer) Send(m *SubscribeTxpoolResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mEVInfraSubscribeTxpoolServer) Recv() (*SubscribeTxpoolRequest, error) {
	m := new(SubscribeTxpoolRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MEVInfra_Simulate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SimulateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MEVInfraServer).Simulate(m, &mEVInfraSimulateServer{stream})
}

type MEVInfra_SimulateServer interface {
	Send(*SimulateResponse) error
	grpc.ServerStream
}

type mEVInfraSimulateServer struct {
	grpc.ServerStream
}

func (x *mEVInfraSimulateServer) Send(m *SimulateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MEVInfra_WatchState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchStateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MEVInfraServer).WatchState(m, &mEVInfraWatchStateServer{stream})
}

type MEVInfra_WatchStateServer interface {
	Send(*WatchStateResponse) error
	grpc.ServerStream
}

type mEVInfraWatchStateServer struct {
	grpc.ServerStream
}

func (x *mEVInfraWatchStateServer) Send(m *WatchStateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MEVInfra_WatchStateStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MEVInfraServer).WatchStateStream(&mEVInfraWatchStateStreamServer{stream})
}

type MEVInfra_WatchStateStreamServer interface {
	Send(*WatchStateResponse) error
	Recv() (*WatchStateStreamRequest, error)
	grpc.ServerStream
}

type mEVInfraWatchStateStreamServer struct {
	grpc.ServerStream
}

func (x *mEVInfraWatchStateStreamServer) Send(m *WatchStateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mEVInfraWatchStateStreamServer) Recv() (*WatchStateStreamRequest, error) {
	m := new(WatchStateStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MEVInfra_HistoricalState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoricalStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).HistoricalState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/HistoricalState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).HistoricalState(ctx, req.(*HistoricalStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_UpdateTxpoolWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTxpoolWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).UpdateTxpoolWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/UpdateTxpoolWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).UpdateTxpoolWhitelist(ctx, req.(*UpdateTxpoolWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_DumpTxpoolWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpTxpoolWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).DumpTxpoolWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/DumpTxpoolWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).DumpTxpoolWhitelist(ctx, req.(*DumpTxpoolWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_RelayTxFeed_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MEVInfraServer).RelayTxFeed(&mEVInfraRelayTxFeedServer{stream})
}

type MEVInfra_RelayTxFeedServer interface {
	SendAndClose(*RelayTxFeedResponse) error
	Recv() (*RelayTxFeedRequest, error)
	grpc.ServerStream
}

type mEVInfraRelayTxFeedServer struct {
	grpc.ServerStream
}

func (x *mEVInfraRelayTxFeedServer) SendAndClose(m *RelayTxFeedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mEVInfraRelayTxFeedServer) Recv() (*RelayTxFeedRequest, error) {
	m := new(RelayTxFeedRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MEVInfra_BatchBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).BatchBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/BatchBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).BatchBundle(ctx, req.(*BatchBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_BroadcastBatchBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastBatchBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).BroadcastBatchBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/BroadcastBatchBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).BroadcastBatchBundle(ctx, req.(*BroadcastBatchBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_WatchBatchBundleV2_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchBatchBundleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MEVInfraServer).WatchBatchBundleV2(m, &mEVInfraWatchBatchBundleV2Server{stream})
}

type MEVInfra_WatchBatchBundleV2Server interface {
	Send(*WatchBatchBundleV2Response) error
	grpc.ServerStream
}

type mEVInfraWatchBatchBundleV2Server struct {
	grpc.ServerStream
}

func (x *mEVInfraWatchBatchBundleV2Server) Send(m *WatchBatchBundleV2Response) error {
	return x.ServerStream.SendMsg(m)
}

func _MEVInfra_GetRawHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawHeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).GetRawHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/GetRawHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).GetRawHeaders(ctx, req.(*GetRawHeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_EthCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthCallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).EthCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/EthCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).EthCall(ctx, req.(*EthCallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_ServeHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeHeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).ServeHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/ServeHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).ServeHeaders(ctx, req.(*ServeHeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_ServeBodies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeBodiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).ServeBodies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/ServeBodies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).ServeBodies(ctx, req.(*ServeBodiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_ServeSnap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServeSnapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).ServeSnap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/ServeSnap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).ServeSnap(ctx, req.(*ServeSnapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_RegisterLocalAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterLocalAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).RegisterLocalAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/RegisterLocalAccounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).RegisterLocalAccounts(ctx, req.(*RegisterLocalAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MEVInfra_PrepareSimulateEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareSimulateEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MEVInfraServer).PrepareSimulateEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.MEVInfra/PrepareSimulateEnv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MEVInfraServer).PrepareSimulateEnv(ctx, req.(*PrepareSimulateEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MEVInfra_ServiceDesc is the grpc.ServiceDesc for MEVInfra service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MEVInfra_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mev.MEVInfra",
	HandlerType: (*MEVInfraServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HistoricalState",
			Handler:    _MEVInfra_HistoricalState_Handler,
		},
		{
			MethodName: "UpdateTxpoolWhitelist",
			Handler:    _MEVInfra_UpdateTxpoolWhitelist_Handler,
		},
		{
			MethodName: "DumpTxpoolWhitelist",
			Handler:    _MEVInfra_DumpTxpoolWhitelist_Handler,
		},
		{
			MethodName: "BatchBundle",
			Handler:    _MEVInfra_BatchBundle_Handler,
		},
		{
			MethodName: "BroadcastBatchBundle",
			Handler:    _MEVInfra_BroadcastBatchBundle_Handler,
		},
		{
			MethodName: "GetRawHeaders",
			Handler:    _MEVInfra_GetRawHeaders_Handler,
		},
		{
			MethodName: "EthCall",
			Handler:    _MEVInfra_EthCall_Handler,
		},
		{
			MethodName: "ServeHeaders",
			Handler:    _MEVInfra_ServeHeaders_Handler,
		},
		{
			MethodName: "ServeBodies",
			Handler:    _MEVInfra_ServeBodies_Handler,
		},
		{
			MethodName: "ServeSnap",
			Handler:    _MEVInfra_ServeSnap_Handler,
		},
		{
			MethodName: "RegisterLocalAccounts",
			Handler:    _MEVInfra_RegisterLocalAccounts_Handler,
		},
		{
			MethodName: "PrepareSimulateEnv",
			Handler:    _MEVInfra_PrepareSimulateEnv_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTxpool",
			Handler:       _MEVInfra_SubscribeTxpool_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Simulate",
			Handler:       _MEVInfra_Simulate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchState",
			Handler:       _MEVInfra_WatchState_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchStateStream",
			Handler:       _MEVInfra_WatchStateStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "RelayTxFeed",
			Handler:       _MEVInfra_RelayTxFeed_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "WatchBatchBundleV2",
			Handler:       _MEVInfra_WatchBatchBundleV2_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "infra.proto",
}

// SuperRelayClient is the client API for SuperRelay service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SuperRelayClient interface {
	// RelayStream opens a stream to communicate with the super relay.
	// Caller must be a relay or another super relay.
	RelayStream(ctx context.Context, opts ...grpc.CallOption) (SuperRelay_RelayStreamClient, error)
	QueryTx(ctx context.Context, in *QueryTxRequest, opts ...grpc.CallOption) (*QueryTxResponse, error)
}

type superRelayClient struct {
	cc grpc.ClientConnInterface
}

func NewSuperRelayClient(cc grpc.ClientConnInterface) SuperRelayClient {
	return &superRelayClient{cc}
}

func (c *superRelayClient) RelayStream(ctx context.Context, opts ...grpc.CallOption) (SuperRelay_RelayStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &SuperRelay_ServiceDesc.Streams[0], "/mev.SuperRelay/RelayStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &superRelayRelayStreamClient{stream}
	return x, nil
}

type SuperRelay_RelayStreamClient interface {
	Send(*RelayStreamRequest) error
	Recv() (*RelayStreamResponse, error)
	grpc.ClientStream
}

type superRelayRelayStreamClient struct {
	grpc.ClientStream
}

func (x *superRelayRelayStreamClient) Send(m *RelayStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *superRelayRelayStreamClient) Recv() (*RelayStreamResponse, error) {
	m := new(RelayStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *superRelayClient) QueryTx(ctx context.Context, in *QueryTxRequest, opts ...grpc.CallOption) (*QueryTxResponse, error) {
	out := new(QueryTxResponse)
	err := c.cc.Invoke(ctx, "/mev.SuperRelay/QueryTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SuperRelayServer is the server API for SuperRelay service.
// All implementations must embed UnimplementedSuperRelayServer
// for forward compatibility
type SuperRelayServer interface {
	// RelayStream opens a stream to communicate with the super relay.
	// Caller must be a relay or another super relay.
	RelayStream(SuperRelay_RelayStreamServer) error
	QueryTx(context.Context, *QueryTxRequest) (*QueryTxResponse, error)
	mustEmbedUnimplementedSuperRelayServer()
}

// UnimplementedSuperRelayServer must be embedded to have forward compatible implementations.
type UnimplementedSuperRelayServer struct {
}

func (UnimplementedSuperRelayServer) RelayStream(SuperRelay_RelayStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method RelayStream not implemented")
}
func (UnimplementedSuperRelayServer) QueryTx(context.Context, *QueryTxRequest) (*QueryTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryTx not implemented")
}
func (UnimplementedSuperRelayServer) mustEmbedUnimplementedSuperRelayServer() {}

// UnsafeSuperRelayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SuperRelayServer will
// result in compilation errors.
type UnsafeSuperRelayServer interface {
	mustEmbedUnimplementedSuperRelayServer()
}

func RegisterSuperRelayServer(s grpc.ServiceRegistrar, srv SuperRelayServer) {
	s.RegisterService(&SuperRelay_ServiceDesc, srv)
}

func _SuperRelay_RelayStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SuperRelayServer).RelayStream(&superRelayRelayStreamServer{stream})
}

type SuperRelay_RelayStreamServer interface {
	Send(*RelayStreamResponse) error
	Recv() (*RelayStreamRequest, error)
	grpc.ServerStream
}

type superRelayRelayStreamServer struct {
	grpc.ServerStream
}

func (x *superRelayRelayStreamServer) Send(m *RelayStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *superRelayRelayStreamServer) Recv() (*RelayStreamRequest, error) {
	m := new(RelayStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SuperRelay_QueryTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SuperRelayServer).QueryTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mev.SuperRelay/QueryTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SuperRelayServer).QueryTx(ctx, req.(*QueryTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SuperRelay_ServiceDesc is the grpc.ServiceDesc for SuperRelay service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SuperRelay_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mev.SuperRelay",
	HandlerType: (*SuperRelayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryTx",
			Handler:    _SuperRelay_QueryTx_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RelayStream",
			Handler:       _SuperRelay_RelayStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "infra.proto",
}
